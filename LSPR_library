class OpticalMaterial:
    """
    A class for any material to be considered for its optical properties.
    Per minimum it needs a name and a source file with (n,k) values for each wavelength.
    Basic methods for this class are separation of refractive index, n or k components
    and permittivity (both as a single pandas DataFrame or separately for Real,
    or Imaginary parts).
    """
    
    def __init__(self, name, source):
        self.name = name
        
        self.refractive_index = pd.read_csv(source)
        p = self.refractive_index
        self.n = p.drop(columns=['k'])
        self.k = p.drop(columns=['n'])
        
        self.permittivity = pd.concat([p.iloc[:,0], p.iloc[:,1]**2 - p.iloc[:,2]**2, 2*p.iloc[:,1] * p.iloc[:,2]], axis=1, keys=[p.columns[0],
                         "Real permittivity, a.u.", "Imaginary permittivity, a.u."])
        self.real_permittivity = self.permittivity.drop(columns=["Imaginary permittivity, a.u."])
        self.imaginary_permittivity = self.permittivity.drop(columns=["Real permittivity, a.u."])

    def regular_xspacing(self, optical_property, spacing):
        
        """
        Takes optical_property, e.g. refractive_index and returns evenly spaced data with defined spacing.
        Using spacing smaller than average spacing in the original data with throw a warning.
        """
        
        # identify a typical spectral spacing
        p = optical_property
        ds = p.iloc[:,0]
        ds.name = p.columns[0]
        minds = min(ds)
        maxds = max(ds)
        lds = len(ds)
        spacings = [ds.iloc[k+1]-ds.iloc[k] for k in range(lds-1)]
        avg_spacing = sum(spacings) / len(spacings)
        x_new = pd.Series(np.arange(minds, maxds, spacing), name="Wavelength, µm")
        x_additional = pd.merge(ds, x_new, how="outer").sort_values(by="Wavelength, µm").reset_index(drop=True)

        # Warn if new spacing is smaller than old spacing
        len_spacing = len(str(spacing))
        if spacing < avg_spacing:
            print("Warning: the specified value of spacing {} is smaller than the average".format(spacing),
                  " value of the spacing from the dataset {}. Interpolation may cause errors,".format(avg_spacing),
                 " depending on the difference between the new spacing and the average old spacing")
        
        
        # Preprocess the data
        # add values separated by new spacing, with NaN as missing values if the value is not there
        new_x = pd.DataFrame(x_additional, columns=['Wavelength, µm'])
        new_empty = pd.DataFrame(columns=list(p.columns[-2:])).fillna(np.nan)
        reg_points = pd.concat([new_x, new_empty], axis=0, keys=list(p.columns))

        # Dataset with additional data to be interpolated
        extended = pd.concat([p, reg_points])
        
        # sort the new dataframe and drop duplicates
        extended = extended.drop_duplicates(subset='Wavelength, µm')
        extended = extended.sort_values(by='Wavelength, µm')

        # reset the index and drop the old one
        extended = extended.reset_index(drop=True)

        # interpolate the NaNs with dataframe.interpolate() - linear interpolation
        extended = extended.interpolate()

        # extract the values separated by 1nm
        regspace = extended[extended.iloc[:,0].isin(x_new)]

        # reset index
        regspace = regspace.reset_index(drop=True)

        return regspace
            
    def __repr__(self):
        return "{} material".format(self.name)
        
        
"""
Rather than adding a form to the OpticalMaterial, which does nothing, it could be better to create another class,
e.g. Nanoparticle, Matrix, Environment. There each can have its own properties, like form, distribution, etc.
"""

class Nanoparticle:
    
    """
    Typical properties of nanoparticles:
    size, concentration, size distribution, absorption cross section, scattering cross section
    """
    
    def __init__(self, material: OpticalMaterial=None, size: float=10, concentration: float=1e18, distribution: str=None):
        self.material = material
        self.size = size
        self.concentration = concentration
        self.distribution = distribution
        
    def modify(self, feature, new):
        try:
            if feature == self.material:
                self.material = new
            elif feature == self.size:
                self.size = new
            elif feature == self.concentration:
                self.concentration = new
            elif feature == self.distribution:
                self.distribution = new
        
    def __repr__(self):
        return "{} nanoparticle with size {} nm and concentration {:.2e} cm^-3. Size distribution: {}.".format(
            self.material, self.size, self.concentration, self.distribution)


class SpectralMeasurement:
    """
    Basic spectral measurements: absorbance, 
    """
    
    matrix_refractive_index = None
    matrix_real_permittivity = None
    nanoparticle_permittivity = None
    nanoparticle_concentration = None
    nanoparticle_size = None
    
    
    def __init__(self, name: str=None, matrix: OpticalMaterial=None, nanoparticle: Nanoparticle=None,
                 thickness: float=1):
        self.name = name
        self.thickness = thickness
        self.matrix = matrix
        self.nanoparticle = nanoparticle
        self.matrix_refractive_index = matrix.refractive_index
        self.matrix_real_permittivity = matrix.permittivity.iloc[:,1]
        self.nanoparticle_permittivity = nanoparticle.material.permittivity
        self.nanoparticle_concentration = nanoparticle.concentration
        self.nanoparticle_size = nanoparticle.size
        
        # Reflectance
        L = 1 - self.matrix_refractive_index['n']
        M = 1 + self.matrix_refractive_index['n']
        reflectance = 100 * abs(L/M)**2
        self.mreflectance = pd.concat([self.matrix_refractive_index.iloc[:,0], reflectance], axis=1,
                                      keys=[self.matrix_refractive_index.columns[0], "Reflectance, %"])
        
        # Absorbance
        # Define f_abs function
        pi = np.pi
        def f_abs(eps_m, e_1, e_2, l_0, C_tot, t):
            c_abs = ((0.8686 * (pi ** 5)) * 1e-30) / 3
            L_abs = c_abs * C_tot * t * (((eps_m ** 2) / (l_0 ** 4)) * (((e_1 - eps_m) ** 2) + (e_2 ** 2)))
            M_abs = (((e_1 + 2*eps_m) ** 2) + (e_2 ** 2))
            f_abs = L_abs / M_abs
            return f_abs
        
        # Define f_sca function
        def f_sca(eps_m, e_1, e_2, l_0, C_tot, t):
            c_sca = 1.3029 * (pi ** 2) * 1e-21
            L_sca = c_sca * C_tot * t * (((eps_m ** 1.5) / l_0) * e_2)
            M_sca = (((e_1 + 2*eps_m) ** 2) + (e_2 ** 2))
            f_sca = L_sca / M_sca
            return f_sca
        
        # Define integrals 1 and 2 - I_1
        def I_1(d, n, mean, sd):
            def integrand(d,n,mean,sd):
                return (d**n)*stats.norm.pdf(d, loc=mean, scale=sd)
            return integrate.simps(integrand(d,n,mean,sd))
        
        n_glass = self.matrix_refractive_index['n']
        k_glass = self.matrix_refractive_index['k']
        eps_m = self.matrix_real_permittivity
        l_0 = self.matrix_refractive_index.iloc[:,0]
        e_1 = self.nanoparticle_permittivity.iloc[:,1]
        e_2 = self.nanoparticle_permittivity.iloc[:,2]
        d = np.linspace(0,100,100)
        C_tot = self.nanoparticle_concentration
        mean = self.nanoparticle_size
        #------------------
        sd = 1   # For now only 1 is allowed.
        #------------------
        t = self.thickness

        # Reflection losses - approximation using matrix only
        mrefl_correction = 1 - 0.01 * self.mreflectance.iloc[:,1]
    
        # Define A_glass function
        L1 = k_glass * t
        A_matrix = 5.4576 * (L1 / l_0)

        # A_nano - inner function
        A_nano = f_abs(eps_m, e_1, e_2, l_0, C_tot, t) * I_1(d, 6, mean, sd) + f_sca(eps_m, e_1, e_2, l_0, C_tot, t) * I_1(d, 3, mean, sd)

        A_comp = A_matrix + A_nano

        self.Abs = pd.concat([l_0, A_comp], axis=1,
                             keys=[self.matrix_refractive_index.columns[0], "Absorbance, a.u."])
        
        #------------------------------
        # WARNING!!!
        # Matrix and nanoparticle datasets must be regularized to the same min, max and spacing.
        #------------------------------
        
    def T(self, R_corr: bool=True):
        
        Abs = self.Abs.iloc[:,1]
        # calculates the transmittance of the sample composite
        transmittance = None
        
        if R_corr == True:
            # evaluate corrected transmittance
            transmittance = (1 - 0.01*self.mreflectance.iloc[:,1]) * np.exp(-(Abs))
        else:
            # evaluate without correction
            transmittance = np.exp(-(Abs))
            
        transmittance = 100*transmittance
        transmittance = pd.concat([self.matrix_refractive_index.iloc[:,0], transmittance], axis=1,
                                  keys=[self.matrix_refractive_index.columns[0], "Transmittance, %"])
        
        return transmittance
    
    def align_datasets(self):
        # add x subsets of matrix and nanoparticle
        mat_per = self.matrix.permittivity.iloc[:,0]
        nano_per = self.nanoparticle.material.permittivity.iloc[:,0]
        aligned_x_subset = pd.concat([mat_per, nano_per]).sort_values().reset_index(drop=True)

        # interpolate data based on new x subset
        interpolated_matrix_RI = pd.merge(aligned_x_subset, self.matrix.refractive_index,
                                          how="outer").interpolate()
        interpolated_matrix_real_permittivity = pd.merge(aligned_x_subset, self.matrix.permittivity,
                                                         how="outer").interpolate().iloc[:,1]
        interpolated_nanoparticle_permittivity = pd.merge(aligned_x_subset,
                                                          self.nanoparticle.material.permittivity,
                                                          how="outer").interpolate()
        
        # initialize a copy SpectralMeasurement
        aligned_measurement = SpectralMeasurement("Aligned data measurement", matrix=self.matrix,
                                                  nanoparticle=self.nanoparticle)
        
        # insert the interpolated input
        aligned_measurement.matrix_refractive_index = interpolated_matrix_RI
        aligned_measurement.matrix_real_permittivity = interpolated_matrix_real_permittivity
        aligned_measurement.nanoparticle_permittivity = interpolated_nanoparticle_permittivity
        
        return aligned_measurement


# Sellmeier fitting

class Sellmeier:

    """
    Takes the data and fits the n-th order Sellmeier equation.
    
    data:
        A dataframe of shape (a,b), where b>=2;
        1st column - wavelength, 2nd column - real refractive index.
    
    n:
        Order of the equation, i.e. the number of summation terms
    """
    
    constants = None
    
    def __init__(self, data: pd.DataFrame = None, n: int = 3):
        self.data = data
        self.n = n
        # Initiate an empty table of constants
        
        terms = []
        for j in range(1,n+1):
            symb = ("B", "C")
            for k in symb:
                terms.append(k+str(j))
    
        self.constants = pd.concat([pd.Series(terms), pd.Series([0 for _ in range(2*n)])],
                                   axis=1, keys=["Constant", "Value"])
    

    def fit_data(self):
        def Sellmeier(x, constants):
    
            Sellm = []
    
            for j in x:
                # get the numerators
                Num = (constants.iloc[:,1][::2] * (j**2)).reset_index(drop=True)
    
                # get the denominators
                Den = (((j**2) - constants.iloc[:,1][1::2])).reset_index(drop=True)
            
                Sellm.append( 1 + (Num / Den).sum() )
    
            Sellm = pd.concat([x, pd.Series(Sellm)], axis=1, keys=[x.name, "n_squared"])
    
        
            return Sellm
        
        n = self.n
        data = self.data
    
        # Preprocess the data
        Sellm_fit = pd.concat([data.iloc[:,0], data.iloc[:,1] ** 2], axis = 1,
                              keys = [data.columns[0], 'n squared'])

        # Run optimization on the glass data
        """
        The optimizing parameters are based on Sellmeier constants for existing glasses.
        p0 initializing values are set on the order of the constants for fused silica.
        """
        
        # Initialize upper bounds and starting values
        up_bounds = [10]*2*n
        p_start = [1]*2*n
        
        up_bounds_3 = [2., 1., 10., 0.01, 0.1, 200.]
        p_start_3 = [0.5, 0.5, 0.7, 0.005, 0.01, 100]
        
        if n<=3:
            up_bounds[:(2*n)] = up_bounds_3[:(2*n)]
            p_start[:(2*n)] = p_start_3[:(2*n)]
        else:
            up_bounds[:6] = up_bounds_3[:6]
            p_start[:6] = p_start[:6]
        
        xdata = Sellm_fit.iloc[:,0]
        ydata = Sellm_fit['n squared']
        popt, pcov = optimize.curve_fit(Sellmeier, xdata, ydata,
                                        bounds = (0, up_bounds),
                                        p0 = p_start)

        # fill the fitted constants (popt) to the table of constants
        self.constants["Value"] = popt
    
        return self.constants
