class OpticalMaterial:
    """
    A class for any material to be considered for its optical properties.
    Per minimum it needs a name and a source file with (n,k) values for each wavelength.
    Basic methods for this class are separation of refractive index, n or k components
    and permittivity (both as a single pandas DataFrame or separately for Real,
    or Imaginary parts).
    """
    
    def __init__(self, name, source):
        self.name = name
        
        self.refractive_index = pd.read_csv(source)
        p = self.refractive_index
        self.n = p.drop(columns=['k'])
        self.k = p.drop(columns=['n'])
        
        self.permittivity = pd.concat([p.iloc[:,0], p.iloc[:,1]**2 - p.iloc[:,2]**2, 2*p.iloc[:,1] * p.iloc[:,2]], axis=1, keys=[p.columns[0],
                         "Real permittivity, a.u.", "Imaginary permittivity, a.u."])
        self.real_permittivity = self.permittivity.drop(columns=["Imaginary permittivity, a.u."])
        self.imaginary_permittivity = self.permittivity.drop(columns=["Real permittivity, a.u."])

    def regular_xspacing(self, optical_property, spacing):
        
        """
        Takes optical_property, e.g. refractive_index and returns evenly spaced data with defined spacing.
        Using spacing smaller than average spacing in the original data with throw a warning.
        """
        
        # identify a typical spectral spacing
        p = optical_property
        ds = p.iloc[:,0]
        ds.name = p.columns[0]
        minds = min(ds)
        maxds = max(ds)
        lds = len(ds)
        spacings = [ds.iloc[k+1]-ds.iloc[k] for k in range(lds-1)]
        avg_spacing = sum(spacings) / len(spacings)
        x_new = pd.Series(np.arange(minds, maxds, spacing), name="Wavelength, µm")
        x_additional = pd.merge(ds, x_new, how="outer").sort_values(by="Wavelength, µm").reset_index(drop=True)

        # Warn if new spacing is smaller than old spacing
        len_spacing = len(str(spacing))
        if spacing < avg_spacing:
            print("Warning: the specified value of spacing {} is smaller than the average".format(spacing),
                  " value of the spacing from the dataset {}. Interpolation may cause errors,".format(avg_spacing),
                 " depending on the difference between the new spacing and the average old spacing")
        
        
        # Preprocess the data
        # add values separated by new spacing, with NaN as missing values if the value is not there
        new_x = pd.DataFrame(x_additional, columns=['Wavelength, µm'])
        new_empty = pd.DataFrame(columns=list(p.columns[-2:])).fillna(np.nan)
        reg_points = pd.concat([new_x, new_empty], axis=0, keys=list(p.columns))

        # Dataset with additional data to be interpolated
        extended = pd.concat([p, reg_points])
        
        # sort the new dataframe and drop duplicates
        extended = extended.drop_duplicates(subset='Wavelength, µm')
        extended = extended.sort_values(by='Wavelength, µm')

        # reset the index and drop the old one
        extended = extended.reset_index(drop=True)

        # interpolate the NaNs with dataframe.interpolate() - linear interpolation
        extended = extended.interpolate()

        # extract the values separated by 1nm
        regspace = extended[extended.iloc[:,0].isin(x_new)]

        # reset index
        regspace = regspace.reset_index(drop=True)

        return regspace
            
    def __repr__(self):
        return "{} material".format(self.name)
        
        
"""
Rather than adding a form to the OpticalMaterial, which does nothing, it could be better to create another class,
e.g. Nanoparticle, Matrix, Environment. There each can have its own properties, like form, distribution, etc.
"""

class Nanoparticle:
    
    """
    Typical properties of nanoparticles:
    size, concentration, size distribution, absorption cross section, scattering cross section
    """
    
    def __init__(self, material: OpticalMaterial=None, size: float=10, concentration: float=1e18, distribution: str=None):
        self.material = material
        self.size = size
        self.concentration = concentration
        self.distribution = distribution
        
    def modify(self, feature, new):
        try:
            if feature == self.material:
                self.material = new
            elif feature == self.size:
                self.size = new
            elif feature == self.concentration:
                self.concentration = new
            elif feature == self.distribution:
                self.distribution = new
        
    def __repr__(self):
        return "{} nanoparticle with size {} nm and concentration {:.2e} cm^-3. Size distribution: {}.".format(
            self.material, self.size, self.concentration, self.distribution)


class SpectralMeasurement:
    """
    Basic spectral measurements: absorbance, 
    """
    
    def __init__(self, name: str=None, matrix: OpticalMaterial=None, nanoparticle: Nanoparticle=None,
                 thickness: float=1):
        self.name = name
        self.form = form
        self.thickness = thickness
        self.matrix = matrix
        self.nanoparticle = nanoparticle
           
    def Abs(self):
        # calculates the absorbance of the sample composite
        return None
        
    def T(self, R_corr: bool=True):
        # calculates the transmittance of the sample composite
        return None
        
    def R(self, ):
        # calculates the reflectance of the sample composite
        return None
